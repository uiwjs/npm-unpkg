{"version":3,"sources":["../node_modules/prismjs/components/prism-racket.js"],"names":["Prism","languages","racket","extend","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","this","RegExp","flags","insertBefore","greedy","alias","rkt"],"mappings":"iGAAAA,MAAMC,UAAUC,OAASF,MAAMC,UAAUE,OAAO,SAAU,CACzD,mBAAoB,CAGnBC,QAAS,2BACTC,YAAY,KAiBdL,MAAMC,UAAUK,IAAIN,MAAMC,UAAUC,QAAQ,SAAUK,EAAKC,GAC1D,GAA+B,WAA3BR,MAAMS,KAAKC,KAAKF,GAAqB,CACxC,IAAIG,EAASH,EAAMG,OAAOC,QAAQ,oCAAoC,SAAUC,EAAGC,EAAIC,GACtF,GAAID,EAAI,CACP,GAAW,MAAPA,EAEH,MAAO,OAER,GAAW,MAAPA,EAEH,MAAO,SAGT,OAAIC,GACmB,MAATF,EAAE,GAAa,KAAO,KACnBE,EAAGH,QAAQ,eAAe,SAAUC,EAAGC,GACtD,MAAU,MAAND,GAAoB,MAAPC,EAET,KAEE,MAAND,GAAoB,MAAPC,EAET,OAEDD,KACH,IAECA,KAGRG,KAAKT,GAAOU,OAAON,EAAQH,EAAMU,WAInClB,MAAMC,UAAUkB,aAAa,SAAU,SAAU,CAChD,KAAQ,CACPf,QAAS,YACTgB,QAAQ,EACRC,MAAO,aAITrB,MAAMC,UAAUqB,IAAMtB,MAAMC,UAAUC","file":"static/js/350.81e4aea7.chunk.js","sourcesContent":["Prism.languages.racket = Prism.languages.extend('scheme', {\n\t'lambda-parameter': {\n\t\t// the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n\t\t// this will just prevent false positives of the `function` pattern\n\t\tpattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n\t\tlookbehind: true\n\t}\n});\n\n// Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n\tif (Prism.util.type(value) === 'RegExp') {\n\t\tvar source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n\t\t\tif (g1) {\n\t\t\t\tif (g1 === '(') {\n\t\t\t\t\t// replace all '(' characters outside character sets\n\t\t\t\t\treturn '[([]';\n\t\t\t\t}\n\t\t\t\tif (g1 === ')') {\n\t\t\t\t\t// replace all ')' characters outside character sets\n\t\t\t\t\treturn '[)\\\\]]';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g2) {\n\t\t\t\tvar prefix = m[1] === '^' ? '[^' : '[';\n\t\t\t\treturn prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n\t\t\t\t\tif (m === '(' || g1 === '(') {\n\t\t\t\t\t\t// replace all '(' characters inside character sets\n\t\t\t\t\t\treturn '([';\n\t\t\t\t\t}\n\t\t\t\t\tif (m === ')' || g1 === ')') {\n\t\t\t\t\t\t// replace all ')' characters inside character sets\n\t\t\t\t\t\treturn ')\\\\]';\n\t\t\t\t\t}\n\t\t\t\t\treturn m;\n\t\t\t\t}) + ']';\n\t\t\t}\n\t\t\treturn m;\n\t\t});\n\n\t\tthis[key] = RegExp(source, value.flags);\n\t}\n});\n\nPrism.languages.insertBefore('racket', 'string', {\n\t'lang': {\n\t\tpattern: /^#lang.+/m,\n\t\tgreedy: true,\n\t\talias: 'keyword'\n\t}\n});\n\nPrism.languages.rkt = Prism.languages.racket;\n"],"sourceRoot":""}