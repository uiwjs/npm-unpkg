{"version":3,"sources":["../node_modules/prismjs/components/prism-js-templates.js"],"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","lookbehind","greedy","alias","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","stringContent","value","add","findTemplateStrings","l","type","embedded"],"mappings":"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","file":"static/js/209.94518ff5.chunk.js","sourcesContent":["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"],"sourceRoot":""}